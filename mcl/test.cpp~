// grappa
#include <Grappa.hpp>
#include <Collective.hpp>
#include <GlobalCompletionEvent.hpp>
#include <Metrics.hpp>

using namespace Grappa;

// stl
#include <vector>
#include <iomanip>
#include <cstring>
#include <limits>

// query library
#include "relation_io.hpp"
#include "MatchesDHT.hpp"
#include "DoubleDHT.hpp"
#include "MapReduce.hpp"
//#include "HashJoin.hpp"
#include "DHT_symmetric.hpp"
#include "Aggregates.hpp"
#include "Iterators.hpp"
#include "radish_utils.h"
#include "stats.h"
#include "strings.h"
#include "dates.h"
#include "relation.hpp"

DEFINE_uint64( nt, 30, "hack: number of tuples");
DEFINE_bool( jsonsplits, false, "interpret input file F as F/part-*,"
                             "and containing json records");

template <typename T>
struct counter {
  T count;
  static GlobalAddress<counter<T>> create(T init) {
    auto res = symmetric_global_alloc<counter<T>>();
    on_all_cores([res, init] {
        res->count = init;
        });           
    return res;
  }
} GRAPPA_BLOCK_ALIGNED;

template <typename T>
T get_count(GlobalAddress<counter<T>> p) {
  return p->count;                           
}

          // can be just the necessary schema
  class MaterializedTupleRef_V1_0_1_2 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    

    static constexpr int numFields() {
      return 3;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V1_0_1_2 _t;
        return

        
            ((char*)&_t.f2) + sizeof(_t.f2) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V1_0_1_2 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f1) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V1_0_1_2 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V1_0_1_2 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V1_0_1_2));
    //}
    MaterializedTupleRef_V1_0_1_2 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
    }

    
    


    MaterializedTupleRef_V1_0_1_2(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V1_0_1_2 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V1_0_1_2 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V1_0_1_2 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V1_0_1_2 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V1_0_1_2::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V1_0_1_2 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V1_0_1_2::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      

      o << ")";
      return o;
    }

    
  } GRAPPA_BLOCK_ALIGNED;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V1_0_1_2& t) {
    return t.dump(o);
  }

Relation<MaterializedTupleRef_V1_0_1_2> V1;

GlobalCompletionEvent V2(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_1_gce_incomplete, [] {
  return V2.incomplete();
});
Relation<aligned_vector<MaterializedTupleRef_V1_0_1_2>> _temp_table_matA;

          // can be just the necessary schema
  class MaterializedTupleRef_V3_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V3_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V3_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V3_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V3_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V3_0));
    //}
    MaterializedTupleRef_V3_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V3_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V3_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V3_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V3_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V3_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V3_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V3_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V3_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V3_0& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V4_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V4_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V4_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V4_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V4_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V4_0));
    //}
    MaterializedTupleRef_V4_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V4_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V4_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V4_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V4_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V4_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V4_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V4_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V4_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V4_0& t) {
    return t.dump(o);
  }

MaterializedTupleRef_V4_0 t_002;
Relation<aligned_vector<MaterializedTupleRef_V3_0>> _temp_table_epsilon;

          // can be just the necessary schema
  class MaterializedTupleRef_V5_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V5_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V5_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V5_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V5_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V5_0));
    //}
    MaterializedTupleRef_V5_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V5_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V5_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V5_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V5_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V5_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V5_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V5_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V5_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V5_0& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V6_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V6_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V6_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V6_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V6_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V6_0));
    //}
    MaterializedTupleRef_V6_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V6_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V6_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V6_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V6_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V6_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V6_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V6_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V6_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V6_0& t) {
    return t.dump(o);
  }

MaterializedTupleRef_V6_0 t_004;
Relation<aligned_vector<MaterializedTupleRef_V5_0>> _temp_table_prunelimit;

          // can be just the necessary schema
  class MaterializedTupleRef_V7_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V7_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V7_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V7_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V7_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V7_0));
    //}
    MaterializedTupleRef_V7_0 (
                               const int64_t& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V7_0(const std::tuple<
        
        int64_t
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        int64_t
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V7_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V7_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V7_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V7_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V7_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V7_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V7_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V7_0& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V8_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V8_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V8_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V8_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V8_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V8_0));
    //}
    MaterializedTupleRef_V8_0 (
                               const int64_t& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V8_0(const std::tuple<
        
        int64_t
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        int64_t
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V8_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V8_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V8_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V8_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V8_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V8_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V8_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V8_0& t) {
    return t.dump(o);
  }

MaterializedTupleRef_V8_0 t_006;
Relation<aligned_vector<MaterializedTupleRef_V7_0>> _temp_table_newchaos;

GlobalCompletionEvent V9(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_5_gce_incomplete, [] {
  return V9.incomplete();
});
Relation<aligned_vector<MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0>> _temp_table_oldchaos;

          // can be just the necessary schema
  class MaterializedTupleRef_V10_0_1_2 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    

    static constexpr int numFields() {
      return 3;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V10_0_1_2 _t;
        return

        
            ((char*)&_t.f2) + sizeof(_t.f2) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V10_0_1_2 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f1) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V10_0_1_2 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V10_0_1_2 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V10_0_1_2));
    //}
    MaterializedTupleRef_V10_0_1_2 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
    }

    
    


    MaterializedTupleRef_V10_0_1_2(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V10_0_1_2 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V10_0_1_2 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V10_0_1_2 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V10_0_1_2 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V10_0_1_2::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V10_0_1_2 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V10_0_1_2::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V10_0_1_2& t) {
    return t.dump(o);
  }

GlobalCompletionEvent V11(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_6_gce_incomplete, [] {
  return V11.incomplete();
});
MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0 t_010;
          // can be just the necessary schema
  class MaterializedTupleRef_V12_0_1_2 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    

    static constexpr int numFields() {
      return 3;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V12_0_1_2 _t;
        return

        
            ((char*)&_t.f2) + sizeof(_t.f2) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V12_0_1_2 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f1) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V12_0_1_2 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V12_0_1_2 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V12_0_1_2));
    //}
    MaterializedTupleRef_V12_0_1_2 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
    }

    
    


    MaterializedTupleRef_V12_0_1_2(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V12_0_1_2 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V12_0_1_2 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V12_0_1_2 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V12_0_1_2 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V12_0_1_2::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V12_0_1_2 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V12_0_1_2::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V12_0_1_2& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V13_0_1_2_3 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    
        double f3;
    

    static constexpr int numFields() {
      return 4;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V13_0_1_2_3 _t;
        return

        
            ((char*)&_t.f3) + sizeof(_t.f3) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V13_0_1_2_3 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (((char*)&_t.f3) - ((char*)&_t.f2)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f2) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V13_0_1_2_3 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V13_0_1_2_3 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V13_0_1_2_3));
    //}
    MaterializedTupleRef_V13_0_1_2_3 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               ,
                       
                               const double& a3
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
            f3 = a3;
        
    }

    
    


    MaterializedTupleRef_V13_0_1_2_3(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
            f3 = std::get<3>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
            std::get<3>(r) = f3;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V13_0_1_2_3 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //        f3 = vals[3];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V13_0_1_2_3 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V13_0_1_2_3 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f3;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << " "
        
        << f3 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V13_0_1_2_3 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V13_0_1_2_3::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V13_0_1_2_3 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V13_0_1_2_3::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      
        o << f3 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V13_0_1_2_3& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V15_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V15_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V15_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V15_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V15_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V15_0_1));
    //}
    MaterializedTupleRef_V15_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V15_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V15_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V15_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V15_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V15_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V15_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V15_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V15_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V15_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V16_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V16_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V16_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V16_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V16_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V16_0));
    //}
    MaterializedTupleRef_V16_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V16_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V16_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V16_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V16_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V16_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V16_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V16_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V16_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V16_0& t) {
    return t.dump(o);
  }

decltype(DHT_symmetric<std::tuple<int64_t>,MaterializedTupleRef_V16_0,hash_tuple::hash<std::tuple<int64_t>>>::create_DHT_symmetric( )) group_hash_000;

          // can be just the necessary schema
  class MaterializedTupleRef_V17_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V17_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V17_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V17_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V17_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V17_0_1));
    //}
    MaterializedTupleRef_V17_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V17_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V17_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V17_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V17_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V17_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V17_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V17_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V17_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V17_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V18_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V18_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V18_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V18_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V18_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V18_0));
    //}
    MaterializedTupleRef_V18_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V18_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V18_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V18_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V18_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V18_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V18_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V18_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V18_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V18_0& t) {
    return t.dump(o);
  }

decltype(DHT_symmetric<std::tuple<int64_t,int64_t>,MaterializedTupleRef_V18_0,hash_tuple::hash<std::tuple<int64_t,int64_t>>>::create_DHT_symmetric( )) group_hash_001;

          // can be just the necessary schema
  class MaterializedTupleRef_V19_0_1_2 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    

    static constexpr int numFields() {
      return 3;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V19_0_1_2 _t;
        return

        
            ((char*)&_t.f2) + sizeof(_t.f2) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V19_0_1_2 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f1) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V19_0_1_2 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V19_0_1_2 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V19_0_1_2));
    //}
    MaterializedTupleRef_V19_0_1_2 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
    }

    
    


    MaterializedTupleRef_V19_0_1_2(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V19_0_1_2 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V19_0_1_2 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V19_0_1_2 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V19_0_1_2 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V19_0_1_2::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V19_0_1_2 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V19_0_1_2::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V19_0_1_2& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V20_0_1_2_3 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    
        int64_t f2;
    
        double f3;
    

    static constexpr int numFields() {
      return 4;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V20_0_1_2_3 _t;
        return

        
            ((char*)&_t.f3) + sizeof(_t.f3) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V20_0_1_2_3 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (((char*)&_t.f3) - ((char*)&_t.f2)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f2) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V20_0_1_2_3 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V20_0_1_2_3 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V20_0_1_2_3));
    //}
    MaterializedTupleRef_V20_0_1_2_3 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               ,
                       
                               const int64_t& a2
                               ,
                       
                               const double& a3
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
            f3 = a3;
        
    }

    
    


    MaterializedTupleRef_V20_0_1_2_3(const std::tuple<
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
            f3 = std::get<3>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
            std::get<3>(r) = f3;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V20_0_1_2_3 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //        f3 = vals[3];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V20_0_1_2_3 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V20_0_1_2_3 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f3;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << " "
        
        << f3 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V20_0_1_2_3 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V20_0_1_2_3::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V20_0_1_2_3 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V20_0_1_2_3::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      
        o << f3 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V20_0_1_2_3& t) {
    return t.dump(o);
  }

GlobalCompletionEvent V22(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_7_gce_incomplete, [] {
  return V22.incomplete();
});
GlobalCompletionEvent V23(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_8_gce_incomplete, [] {
  return V23.incomplete();
});
          // can be just the necessary schema
  class MaterializedTupleRef_V25_0_1_2_3_4_5 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    
        int64_t f3;
    
        int64_t f4;
    
        double f5;
    

    static constexpr int numFields() {
      return 6;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V25_0_1_2_3_4_5 _t;
        return

        
            ((char*)&_t.f5) + sizeof(_t.f5) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V25_0_1_2_3_4_5 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (((char*)&_t.f3) - ((char*)&_t.f2)) << ",";
        
        std::cout << (((char*)&_t.f4) - ((char*)&_t.f3)) << ",";
        
        std::cout << (((char*)&_t.f5) - ((char*)&_t.f4)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f4) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V25_0_1_2_3_4_5 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V25_0_1_2_3_4_5 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V25_0_1_2_3_4_5));
    //}
    MaterializedTupleRef_V25_0_1_2_3_4_5 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               ,
                       
                               const int64_t& a3
                               ,
                       
                               const int64_t& a4
                               ,
                       
                               const double& a5
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
            f3 = a3;
        
            f4 = a4;
        
            f5 = a5;
        
    }

    
    


    MaterializedTupleRef_V25_0_1_2_3_4_5(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
            f3 = std::get<3>(o);
        
            f4 = std::get<4>(o);
        
            f5 = std::get<5>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
            std::get<3>(r) = f3;
        
            std::get<4>(r) = f4;
        
            std::get<5>(r) = f5;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V25_0_1_2_3_4_5 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //        f3 = vals[3];
    //    
    //        f4 = vals[4];
    //    
    //        f5 = vals[5];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V25_0_1_2_3_4_5 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V25_0_1_2_3_4_5 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f3;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f4;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f5;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << " "
        
        << f3 << " "
        
        << f4 << " "
        
        << f5 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V25_0_1_2_3_4_5 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V25_0_1_2_3_4_5::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V25_0_1_2_3_4_5 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V25_0_1_2_3_4_5::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      
        o << f3 << ",";
      
        o << f4 << ",";
      
        o << f5 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V25_0_1_2_3_4_5& t) {
    return t.dump(o);
  }

static MaterializedTupleRef_V25_0_1_2_3_4_5 create_V26(const MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& t1, const MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& t2) {
    MaterializedTupleRef_V25_0_1_2_3_4_5 t;
    
        t.f0 = t1.f0;
    
        t.f1 = t1.f1;
    
        t.f2 = t1.f2;
    

    
        t.f3 = t2.f0;
    
        t.f4 = t2.f1;
    
        t.f5 = t2.f2;
    

    return t;
}
MaterializedTupleRef_V18_0 __V18_update(const MaterializedTupleRef_V18_0& state, const MaterializedTupleRef_V19_0_1_2& t_017) {
    
    auto _v0 = Aggregates::SUM<double, double>(state.f0,t_017.f2);
    
    return MaterializedTupleRef_V18_0(std::make_tuple(_v0));
}
MaterializedTupleRef_V18_0 __V18_init() {
    
    auto _v0 = Aggregates::Zero<double>();
    

    return MaterializedTupleRef_V18_0( std::make_tuple(_v0) );
}
GlobalCompletionEvent V28(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_9_gce_incomplete, [] {
  return V28.incomplete();
});
          // can be just the necessary schema
  class MaterializedTupleRef_V29_0_1_2 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    

    static constexpr int numFields() {
      return 3;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V29_0_1_2 _t;
        return

        
            ((char*)&_t.f2) + sizeof(_t.f2) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V29_0_1_2 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f1) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V29_0_1_2 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V29_0_1_2 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V29_0_1_2));
    //}
    MaterializedTupleRef_V29_0_1_2 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
    }

    
    


    MaterializedTupleRef_V29_0_1_2(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V29_0_1_2 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V29_0_1_2 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V29_0_1_2 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V29_0_1_2 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V29_0_1_2::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V29_0_1_2 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V29_0_1_2::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V29_0_1_2& t) {
    return t.dump(o);
  }

MaterializedTupleRef_V16_0 __V16_update(const MaterializedTupleRef_V16_0& state, const MaterializedTupleRef_V17_0_1& t_015) {
    
    auto _v0 = Aggregates::SUM<double, double>(state.f0,t_015.f1);
    
    return MaterializedTupleRef_V16_0(std::make_tuple(_v0));
}
MaterializedTupleRef_V16_0 __V16_init() {
    
    auto _v0 = Aggregates::Zero<double>();
    

    return MaterializedTupleRef_V16_0( std::make_tuple(_v0) );
}
GlobalCompletionEvent V31(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_10_gce_incomplete, [] {
  return V31.incomplete();
});
          // can be just the necessary schema
  class MaterializedTupleRef_V32_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V32_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V32_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V32_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V32_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V32_0_1));
    //}
    MaterializedTupleRef_V32_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V32_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V32_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V32_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V32_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V32_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V32_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V32_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V32_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V32_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V33_0_1_2 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    

    static constexpr int numFields() {
      return 3;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V33_0_1_2 _t;
        return

        
            ((char*)&_t.f2) + sizeof(_t.f2) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V33_0_1_2 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f1) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V33_0_1_2 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V33_0_1_2 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V33_0_1_2));
    //}
    MaterializedTupleRef_V33_0_1_2 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
    }

    
    


    MaterializedTupleRef_V33_0_1_2(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V33_0_1_2 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V33_0_1_2 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V33_0_1_2 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V33_0_1_2 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V33_0_1_2::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V33_0_1_2 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V33_0_1_2::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V33_0_1_2& t) {
    return t.dump(o);
  }

GlobalCompletionEvent V35(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_11_gce_incomplete, [] {
  return V35.incomplete();
});
          // can be just the necessary schema
  class MaterializedTupleRef_V36_0_1_2 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    

    static constexpr int numFields() {
      return 3;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V36_0_1_2 _t;
        return

        
            ((char*)&_t.f2) + sizeof(_t.f2) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V36_0_1_2 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f1) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V36_0_1_2 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V36_0_1_2 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V36_0_1_2));
    //}
    MaterializedTupleRef_V36_0_1_2 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
    }

    
    


    MaterializedTupleRef_V36_0_1_2(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V36_0_1_2 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V36_0_1_2 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V36_0_1_2 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V36_0_1_2 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V36_0_1_2::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V36_0_1_2 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V36_0_1_2::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V36_0_1_2& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V38_0_1_2_3_4 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    
        int64_t f3;
    
        double f4;
    

    static constexpr int numFields() {
      return 5;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V38_0_1_2_3_4 _t;
        return

        
            ((char*)&_t.f4) + sizeof(_t.f4) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V38_0_1_2_3_4 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (((char*)&_t.f3) - ((char*)&_t.f2)) << ",";
        
        std::cout << (((char*)&_t.f4) - ((char*)&_t.f3)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f3) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V38_0_1_2_3_4 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V38_0_1_2_3_4 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V38_0_1_2_3_4));
    //}
    MaterializedTupleRef_V38_0_1_2_3_4 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               ,
                       
                               const int64_t& a3
                               ,
                       
                               const double& a4
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
            f3 = a3;
        
            f4 = a4;
        
    }

    
    


    MaterializedTupleRef_V38_0_1_2_3_4(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
            f3 = std::get<3>(o);
        
            f4 = std::get<4>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
            std::get<3>(r) = f3;
        
            std::get<4>(r) = f4;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V38_0_1_2_3_4 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //        f3 = vals[3];
    //    
    //        f4 = vals[4];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V38_0_1_2_3_4 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V38_0_1_2_3_4 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f3;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f4;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << " "
        
        << f3 << " "
        
        << f4 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V38_0_1_2_3_4 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V38_0_1_2_3_4::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V38_0_1_2_3_4 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V38_0_1_2_3_4::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      
        o << f3 << ",";
      
        o << f4 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V38_0_1_2_3_4& t) {
    return t.dump(o);
  }

static MaterializedTupleRef_V38_0_1_2_3_4 create_V39(const MaterializedTupleRef_V33_0_1_2& t1, const MaterializedTupleRef_V15_0_1& t2) {
    MaterializedTupleRef_V38_0_1_2_3_4 t;
    
        t.f0 = t1.f0;
    
        t.f1 = t1.f1;
    
        t.f2 = t1.f2;
    

    
        t.f3 = t2.f0;
    
        t.f4 = t2.f1;
    

    return t;
}
          // can be just the necessary schema
  class MaterializedTupleRef_V40_0_1_2_3 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        int64_t f1;
    
        double f2;
    
        double f3;
    

    static constexpr int numFields() {
      return 4;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V40_0_1_2_3 _t;
        return

        
            ((char*)&_t.f3) + sizeof(_t.f3) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V40_0_1_2_3 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (((char*)&_t.f3) - ((char*)&_t.f2)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f2) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V40_0_1_2_3 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V40_0_1_2_3 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V40_0_1_2_3));
    //}
    MaterializedTupleRef_V40_0_1_2_3 (
                               const int64_t& a0
                               ,
                       
                               const int64_t& a1
                               ,
                       
                               const double& a2
                               ,
                       
                               const double& a3
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
            f3 = a3;
        
    }

    
    


    MaterializedTupleRef_V40_0_1_2_3(const std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
            f3 = std::get<3>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        int64_t
        ,
        
        double
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
            std::get<3>(r) = f3;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V40_0_1_2_3 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //        f3 = vals[3];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V40_0_1_2_3 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V40_0_1_2_3 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f3;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << " "
        
        << f3 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V40_0_1_2_3 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V40_0_1_2_3::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V40_0_1_2_3 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V40_0_1_2_3::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      
        o << f3 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V40_0_1_2_3& t) {
    return t.dump(o);
  }

static MaterializedTupleRef_V40_0_1_2_3 create_V41(const MaterializedTupleRef_V12_0_1_2& t1, const MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0& t2) {
    MaterializedTupleRef_V40_0_1_2_3 t;
    
        t.f0 = t1.f0;
    
        t.f1 = t1.f1;
    
        t.f2 = t1.f2;
    

    
        t.f3 = t2.f0;
    

    return t;
}
Relation<aligned_vector<MaterializedTupleRef_V10_0_1_2>> _temp_table_prunedA;

          // can be just the necessary schema
  class MaterializedTupleRef_V42_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V42_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V42_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V42_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V42_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V42_0));
    //}
    MaterializedTupleRef_V42_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V42_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V42_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V42_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V42_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V42_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V42_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V42_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V42_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } GRAPPA_BLOCK_ALIGNED;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V42_0& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V43_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V43_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V43_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V43_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V43_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V43_0));
    //}
    MaterializedTupleRef_V43_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V43_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V43_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V43_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V43_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V43_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V43_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V43_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V43_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V43_0& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V44_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V44_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V44_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V44_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V44_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V44_0_1));
    //}
    MaterializedTupleRef_V44_0_1 (
                               const double& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V44_0_1(const std::tuple<
        
        double
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        double
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V44_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V44_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V44_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V44_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V44_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V44_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V44_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V44_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V46_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V46_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V46_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V46_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V46_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V46_0_1));
    //}
    MaterializedTupleRef_V46_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V46_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V46_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V46_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V46_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V46_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V46_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V46_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V46_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V46_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V47_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V47_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V47_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V47_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V47_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V47_0));
    //}
    MaterializedTupleRef_V47_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V47_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V47_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V47_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V47_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V47_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V47_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V47_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V47_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V47_0& t) {
    return t.dump(o);
  }

decltype(DHT_symmetric<std::tuple<int64_t>,MaterializedTupleRef_V47_0,hash_tuple::hash<std::tuple<int64_t>>>::create_DHT_symmetric( )) group_hash_003;

          // can be just the necessary schema
  class MaterializedTupleRef_V48_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V48_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V48_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V48_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V48_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V48_0_1));
    //}
    MaterializedTupleRef_V48_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V48_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V48_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V48_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V48_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V48_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V48_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V48_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V48_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V48_0_1& t) {
    return t.dump(o);
  }

GlobalCompletionEvent V49(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_12_gce_incomplete, [] {
  return V49.incomplete();
});
MaterializedTupleRef_V47_0 __V47_update(const MaterializedTupleRef_V47_0& state, const MaterializedTupleRef_V48_0_1& t_033) {
    
    auto _v0 = Aggregates::SUM<double, double>(state.f0,t_033.f1);
    
    return MaterializedTupleRef_V47_0(std::make_tuple(_v0));
}
MaterializedTupleRef_V47_0 __V47_init() {
    
    auto _v0 = Aggregates::Zero<double>();
    

    return MaterializedTupleRef_V47_0( std::make_tuple(_v0) );
}
GlobalCompletionEvent V51(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_13_gce_incomplete, [] {
  return V51.incomplete();
});
          // can be just the necessary schema
  class MaterializedTupleRef_V52_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V52_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V52_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V52_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V52_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V52_0_1));
    //}
    MaterializedTupleRef_V52_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V52_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V52_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V52_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V52_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V52_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V52_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V52_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V52_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V52_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V53_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V53_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V53_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V53_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V53_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V53_0_1));
    //}
    MaterializedTupleRef_V53_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V53_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V53_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V53_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V53_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V53_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V53_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V53_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V53_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V53_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V54_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V54_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V54_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V54_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V54_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V54_0));
    //}
    MaterializedTupleRef_V54_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V54_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V54_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V54_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V54_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V54_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V54_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V54_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V54_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V54_0& t) {
    return t.dump(o);
  }

decltype(DHT_symmetric<std::tuple<int64_t>,MaterializedTupleRef_V54_0,hash_tuple::hash<std::tuple<int64_t>>>::create_DHT_symmetric( )) group_hash_004;

          // can be just the necessary schema
  class MaterializedTupleRef_V55_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V55_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V55_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V55_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V55_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V55_0_1));
    //}
    MaterializedTupleRef_V55_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V55_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V55_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V55_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V55_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V55_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V55_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V55_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V55_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V55_0_1& t) {
    return t.dump(o);
  }

GlobalCompletionEvent V56(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_14_gce_incomplete, [] {
  return V56.incomplete();
});
MaterializedTupleRef_V54_0 __V54_update(const MaterializedTupleRef_V54_0& state, const MaterializedTupleRef_V55_0_1& t_038) {
    
    auto _v0 = Aggregates::MAX<double, double>(state.f0,t_038.f1);
    
    return MaterializedTupleRef_V54_0(std::make_tuple(_v0));
}
MaterializedTupleRef_V54_0 __V54_init() {
    
    auto _v0 = std::numeric_limits<double>::lowest();
    

    return MaterializedTupleRef_V54_0( std::make_tuple(_v0) );
}
GlobalCompletionEvent V58(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_15_gce_incomplete, [] {
  return V58.incomplete();
});
          // can be just the necessary schema
  class MaterializedTupleRef_V59_0_1 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    

    static constexpr int numFields() {
      return 2;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V59_0_1 _t;
        return

        
            ((char*)&_t.f1) + sizeof(_t.f1) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V59_0_1 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f0) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V59_0_1 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V59_0_1 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V59_0_1));
    //}
    MaterializedTupleRef_V59_0_1 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
    }

    
    


    MaterializedTupleRef_V59_0_1(const std::tuple<
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V59_0_1 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V59_0_1 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V59_0_1 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V59_0_1 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V59_0_1::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V59_0_1 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V59_0_1::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V59_0_1& t) {
    return t.dump(o);
  }

          // can be just the necessary schema
  class MaterializedTupleRef_V61_0_1_2_3 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        int64_t f0;
    
        double f1;
    
        int64_t f2;
    
        double f3;
    

    static constexpr int numFields() {
      return 4;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V61_0_1_2_3 _t;
        return

        
            ((char*)&_t.f3) + sizeof(_t.f3) - ((char*)&_t);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V61_0_1_2_3 _t;

        
        
        std::cout << (((char*)&_t.f1) - ((char*)&_t.f0)) << ",";
        
        std::cout << (((char*)&_t.f2) - ((char*)&_t.f1)) << ",";
        
        std::cout << (((char*)&_t.f3) - ((char*)&_t.f2)) << ",";
        
        std::cout << (_t.fieldsSize() - (((char*)&_t.f2) - ((char*)&_t)));
        std::cout << std::endl;
        


    }

    MaterializedTupleRef_V61_0_1_2_3 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V61_0_1_2_3 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V61_0_1_2_3));
    //}
    MaterializedTupleRef_V61_0_1_2_3 (
                               const int64_t& a0
                               ,
                       
                               const double& a1
                               ,
                       
                               const int64_t& a2
                               ,
                       
                               const double& a3
                               
                       
                       ) {
        
            f0 = a0;
        
            f1 = a1;
        
            f2 = a2;
        
            f3 = a3;
        
    }

    
    


    MaterializedTupleRef_V61_0_1_2_3(const std::tuple<
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
            f1 = std::get<1>(o);
        
            f2 = std::get<2>(o);
        
            f3 = std::get<3>(o);
        
     }

     std::tuple<
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        int64_t
        ,
        
        double
        ,
        
        int64_t
        ,
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
            std::get<1>(r) = f1;
        
            std::get<2>(r) = f2;
        
            std::get<3>(r) = f3;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V61_0_1_2_3 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //        f1 = vals[1];
    //    
    //        f2 = vals[2];
    //    
    //        f3 = vals[3];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V61_0_1_2_3 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V61_0_1_2_3 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f1;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f2;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f3;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << " "
        
        << f1 << " "
        
        << f2 << " "
        
        << f3 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V61_0_1_2_3 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V61_0_1_2_3::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V61_0_1_2_3 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V61_0_1_2_3::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      
        o << f1 << ",";
      
        o << f2 << ",";
      
        o << f3 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V61_0_1_2_3& t) {
    return t.dump(o);
  }

static MaterializedTupleRef_V61_0_1_2_3 create_V62(const MaterializedTupleRef_V53_0_1& t1, const MaterializedTupleRef_V46_0_1& t2) {
    MaterializedTupleRef_V61_0_1_2_3 t;
    
        t.f0 = t1.f0;
    
        t.f1 = t1.f1;
    

    
        t.f2 = t2.f0;
    
        t.f3 = t2.f1;
    

    return t;
}
MaterializedTupleRef_V42_0 __V42_update(const MaterializedTupleRef_V42_0& state, const MaterializedTupleRef_V43_0& t_029) {
    
    auto _v0 = Aggregates::MAX<double, double>(state.f0,t_029.f0);
    
    return MaterializedTupleRef_V42_0(std::make_tuple(_v0));
}
MaterializedTupleRef_V42_0 __V42_init() {
    
    auto _v0 = std::numeric_limits<double>::lowest();
    

    return MaterializedTupleRef_V42_0( std::make_tuple(_v0) );
}
MaterializedTupleRef_V42_0 __V42_combine(const MaterializedTupleRef_V42_0& state0, const MaterializedTupleRef_V42_0& state1) {
    
    auto _v0 = Aggregates::MAX<double, double>(state0.f0,state1.f0);
    
    return MaterializedTupleRef_V42_0(std::make_tuple(_v0));
}
GlobalCompletionEvent V63(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_16_gce_incomplete, [] {
  return V63.incomplete();
});
          // can be just the necessary schema
  class MaterializedTupleRef_V64_0 {
    // Invariant: data stored in _fields is always in the representation
    // specified by _scheme.

    public:
    
        double f0;
    

    static constexpr int numFields() {
      return 1;
    }

    // size of all fields in struct removing only end padding
    static size_t fieldsSize() {
        const MaterializedTupleRef_V64_0 _t;
        return

        
            sizeof(_t.f0);
         
    }

    // debugging function to get storage sizes
    static void print_representation() {
        const MaterializedTupleRef_V64_0 _t;

        
        std::cout << _t.fieldsSize() << std::endl;
        


    }

    MaterializedTupleRef_V64_0 () {
      // no-op
    }

    //template <typename OT>
    //MaterializedTupleRef_V64_0 (const OT& other) {
    //  std::memcpy(this, &other, sizeof(MaterializedTupleRef_V64_0));
    //}
    MaterializedTupleRef_V64_0 (
                               const double& a0
                               
                       
                       ) {
        
            f0 = a0;
        
    }

    
    


    MaterializedTupleRef_V64_0(const std::tuple<
        
        double
        
        
            >& o) {
        
            f0 = std::get<0>(o);
        
     }

     std::tuple<
        
        double
        
        
     > to_tuple() {

        std::tuple<
        
        double
        
        
        > r;
        
            std::get<0>(r) = f0;
        
        return r;
     }

    // shamelessly terrible disambiguation: one solution is named factory methods
    //MaterializedTupleRef_V64_0 (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
    //    
    //        f0 = vals[0];
    //    
    //}

    // use the tuple schema to interpret the input stream
    static MaterializedTupleRef_V64_0 fromIStream(std::istream& ss, char delim=' ') {
        MaterializedTupleRef_V64_0 _ret;

        
            
               {
               // use operator>> to parse into proper numeric type
               ss >> _ret.f0;
               //throw away the next delimiter
               std::string _temp;
               std::getline(ss, _temp, delim);
               }
            
        

        return _ret;
    }

    void toOStream(std::ostream& os) const {
        os.write((char*)this, this->fieldsSize());
    }

    void toOStreamAscii(std::ostream& os) const {
        os
        
        << f0 << std::endl;
    }

    //template <typename Tuple, typename T>
    //MaterializedTupleRef_V64_0 (const Tuple& v0, const T& from) {
    //    constexpr size_t v0_size = std::tuple_size<Tuple>::value;
    //    constexpr int from_size = T::numFields();
    //    static_assert(MaterializedTupleRef_V64_0::numFields() == (v0_size + from_size), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //    std::memcpy(((char*)&_fields)+v0_size*sizeof(int64_t), &(from._fields), from_size*sizeof(int64_t));
    //}

    //template <typename Tuple>
    //MaterializedTupleRef_V64_0 (const Tuple& v0) {
    //    static_assert(MaterializedTupleRef_V64_0::numFields() == (std::tuple_size<Tuple>::value), "constructor only works on same number of total fields");
    //    TupleUtils::assign<0, decltype(_scheme)>(_fields, v0);
    //}

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      
        o << f0 << ",";
      

      o << ")";
      return o;
    }

    
  } ;

  std::ostream& operator<< (std::ostream& o, const MaterializedTupleRef_V64_0& t) {
    return t.dump(o);
  }

Relation<aligned_vector<MaterializedTupleRef_V64_0>> _temp_table_newchaos;

GlobalCompletionEvent V65(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_17_gce_incomplete, [] {
  return V65.incomplete();
});
Relation<aligned_vector<MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2>> _temp_table_matA;

GlobalCompletionEvent V66(true);
GRAPPA_DEFINE_METRIC(CallbackMetric<int64_t>, app_18_gce_incomplete, [] {
  return V66.incomplete();
});
std::vector<MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0> result;
typedef MatchesDHT<std::tuple<int64_t>, MaterializedTupleRef_V15_0_1, hash_tuple::hash<std::tuple<int64_t>>> DHT_MaterializedTupleRef_V15_0_1;
DHT_MaterializedTupleRef_V15_0_1 hash_000;
typedef MatchesDHT<std::tuple<int64_t>, MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2, hash_tuple::hash<std::tuple<int64_t>>> DHT_MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2;
DHT_MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2 hash_001;
typedef MatchesDHT<std::tuple<int64_t>, MaterializedTupleRef_V46_0_1, hash_tuple::hash<std::tuple<int64_t>>> DHT_MaterializedTupleRef_V46_0_1;
DHT_MaterializedTupleRef_V46_0_1 hash_002;

StringIndex string_index;
void init( ) {
}

void query() {
    double start, end;
    double saved_scan_runtime = 0, saved_init_runtime = 0;
    start = walltime();

     {
    decltype(_temp_table_matA) l__temp_table_matA;
    l__temp_table_matA.data = Grappa::symmetric_global_alloc<aligned_vector<T>>();
    l__temp_table_matA.numtuples = 0; // starts empty, but it could get filled
                           // Often we may not want to bother counting, so this
                           // field may become incoherent.

    // make it available everywhere
    on_all_cores([=] {
        _temp_table_matA = l__temp_table_matA;
    });
}
{
    decltype(_temp_table_epsilon) l__temp_table_epsilon;
    l__temp_table_epsilon.data = Grappa::symmetric_global_alloc<aligned_vector<T>>();
    l__temp_table_epsilon.numtuples = 0; // starts empty, but it could get filled
                           // Often we may not want to bother counting, so this
                           // field may become incoherent.

    // make it available everywhere
    on_all_cores([=] {
        _temp_table_epsilon = l__temp_table_epsilon;
    });
}
{
    decltype(_temp_table_prunelimit) l__temp_table_prunelimit;
    l__temp_table_prunelimit.data = Grappa::symmetric_global_alloc<aligned_vector<T>>();
    l__temp_table_prunelimit.numtuples = 0; // starts empty, but it could get filled
                           // Often we may not want to bother counting, so this
                           // field may become incoherent.

    // make it available everywhere
    on_all_cores([=] {
        _temp_table_prunelimit = l__temp_table_prunelimit;
    });
}
{
    decltype(_temp_table_newchaos) l__temp_table_newchaos;
    l__temp_table_newchaos.data = Grappa::symmetric_global_alloc<aligned_vector<T>>();
    l__temp_table_newchaos.numtuples = 0; // starts empty, but it could get filled
                           // Often we may not want to bother counting, so this
                           // field may become incoherent.

    // make it available everywhere
    on_all_cores([=] {
        _temp_table_newchaos = l__temp_table_newchaos;
    });
}
{
    decltype(_temp_table_oldchaos) l__temp_table_oldchaos;
    l__temp_table_oldchaos.data = Grappa::symmetric_global_alloc<aligned_vector<T>>();
    l__temp_table_oldchaos.numtuples = 0; // starts empty, but it could get filled
                           // Often we may not want to bother counting, so this
                           // field may become incoherent.

    // make it available everywhere
    on_all_cores([=] {
        _temp_table_oldchaos = l__temp_table_oldchaos;
    });
}
hash_000.init_global_DHT( &hash_000, cores()*16*1024 );
auto l_group_hash_000 = DHT_symmetric<std::tuple<int64_t>,MaterializedTupleRef_V16_0,hash_tuple::hash<std::tuple<int64_t>>>::create_DHT_symmetric( );
on_all_cores([=] {
  group_hash_000 = l_group_hash_000;
});
auto l_group_hash_001 = DHT_symmetric<std::tuple<int64_t,int64_t>,MaterializedTupleRef_V18_0,hash_tuple::hash<std::tuple<int64_t,int64_t>>>::create_DHT_symmetric( );
on_all_cores([=] {
  group_hash_001 = l_group_hash_001;
});
hash_001.init_global_DHT( &hash_001, cores()*16*1024 );
{
    decltype(_temp_table_prunedA) l__temp_table_prunedA;
    l__temp_table_prunedA.data = Grappa::symmetric_global_alloc<aligned_vector<T>>();
    l__temp_table_prunedA.numtuples = 0; // starts empty, but it could get filled
                           // Often we may not want to bother counting, so this
                           // field may become incoherent.

    // make it available everywhere
    on_all_cores([=] {
        _temp_table_prunedA = l__temp_table_prunedA;
    });
}
auto group_hash_002 = symmetric_global_alloc<MaterializedTupleRef_V42_0>();
hash_002.init_global_DHT( &hash_002, cores()*16*1024 );
auto l_group_hash_003 = DHT_symmetric<std::tuple<int64_t>,MaterializedTupleRef_V47_0,hash_tuple::hash<std::tuple<int64_t>>>::create_DHT_symmetric( );
on_all_cores([=] {
  group_hash_003 = l_group_hash_003;
});
auto l_group_hash_004 = DHT_symmetric<std::tuple<int64_t>,MaterializedTupleRef_V54_0,hash_tuple::hash<std::tuple<int64_t>>>::create_DHT_symmetric( );
on_all_cores([=] {
  group_hash_004 = l_group_hash_004;
});

    end = walltime();
    init_runtime += (end-start);
    saved_init_runtime += (end-start);

    Grappa::Metrics::reset();
Grappa::Metrics::reset();

auto start_V67 = walltime();

        
        auto start_0 = walltime();
VLOG(1)  << "timestamp 0 start " << std::setprecision(15) << start_0;

{
    if (FLAGS_bin) {
        BinaryRelationFileReader<MaterializedTupleRef_V1_0_1_2> reader;
        V1 = reader.read( FLAGS_input_file_matrix + ".bin" );
    } else if (FLAGS_jsonsplits) {
        SplitsRelationFileReader<JSONRowParser<MaterializedTupleRef_V1_0_1_2,&schema_V1>, MaterializedTupleRef_V1_0_1_2> reader;
        V1 = reader.read( FLAGS_input_file_matrix );
    } else {
        V1.data = readTuples<MaterializedTupleRef_V1_0_1_2>( FLAGS_input_file_matrix, FLAGS_nt);
        V1.numtuples = FLAGS_nt;
        auto l_V1 = V1;
        on_all_cores([=]{ V1 = l_V1; });
    }
}
auto end_0 = walltime();
auto runtime_0 = end_0 - start_0;
VLOG(1)  << "pipeline 0: " << runtime_0 << " s";

VLOG(1)  << "timestamp 0 end " << std::setprecision(15) << end_0;

        
auto end_V67 = walltime();

auto runtime_V67 = end_V67 - start_V67;

saved_scan_runtime += runtime_V67;
VLOG(1) << "pipeline group V67: " << runtime_V67 << " s";
Grappa::Metrics::reset();
Grappa::Metrics::reset();
Grappa::Metrics::start_tracing();
auto start_V68 = walltime();
// Compiled subplan for GrappaSequence[GrappaStoreTemp(matA)[GrappaMemoryScan(global_array, None) [GrappaFileScan(public:adhoc:matrix)]],GrappaStoreTemp(epsilon)[GrappaApply(_COLUMN0_=0.001)[SingletonRelation]],GrappaStoreTemp(prunelimit)[GrappaApply(_COLUMN0_=1e-05)[SingletonRelation]],GrappaStoreTemp(newchaos)[GrappaApply(_COLUMN0_=1000)[SingletonRelation]],GrappaDoWhile[GrappaStoreTemp(oldchaos)[GrappaMemoryScan(symmetric_array, newchaos) [GrappaNullInput(newchaos)]],GrappaStoreTemp(prunedA)[GrappaApply(row=row,col=col,value=value)[GrappaSelect(($2 > $3))[GrappaBroadcastCrossProduct[GrappaApply(row=row,col=col,value=(value / colsum))[GrappaApply(row=$0,col=$1,value=$2,colsum=$4)[GrappaHashJoin(($1 = $3))[GrappaApply(row=$0,col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]],GrappaApply(col=$0,colsum=$1)[GrappaGroupBy(col; SUM(value))[GrappaApply(col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]]]]]]],GrappaMemoryScan(symmetric_array, prunelimit) [GrappaNullInput(prunelimit)]]]]],GrappaStoreTemp(newchaos)[GrappaGroupBy(; MAX($0))[GrappaApply(_COLUMN0_=(maxVal - sumSquare))[GrappaApply(maxVal=$1,sumSquare=$3)[GrappaHashJoin(($0 = $2))[GrappaApply(col=$0,maxVal=$1)[GrappaGroupBy(col; MAX(value))[GrappaApply(col=$1,value=$2)[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]],GrappaApply(col=$0,sumSquare=$1)[GrappaGroupBy(col; SUM($1))[GrappaApply(col=$1,_COLUMN1_=(value * value))[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]]]]]]],GrappaStoreTemp(matA)[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]],GrappaApply(_COLUMN0_=(($1 - $0) > $2))[GrappaBroadcastCrossProduct[GrappaBroadcastCrossProduct[GrappaMemoryScan(symmetric_array, newchaos) [GrappaNullInput(newchaos)],GrappaMemoryScan(symmetric_array, oldchaos) [GrappaNullInput(oldchaos)]],GrappaMemoryScan(symmetric_array, epsilon) [GrappaNullInput(epsilon)]]]],GrappaStore(public:adhoc:OUTPUT)[GrappaMemoryScan(symmetric_array, newchaos) [GrappaNullInput(newchaos)]]]

// recycle result vectors _temp_table_matA
on_all_cores([=] {
    _temp_table_matA.data->clear();
});CompletionEvent p_task_1;
spawn(&p_task_1, [=] {

        
        auto start_1 = walltime();
VLOG(1)  << "timestamp 1 start " << std::setprecision(15) << start_1;

forall<&V2>( t_000.data, t_000.numtuples, [=](int64_t i, MaterializedTupleRef_V1_0_1_2& t_000) {
_temp_table_matA.data->push_back(t_000);
});
auto end_1 = walltime();
auto runtime_1 = end_1 - start_1;
VLOG(1)  << "pipeline 1: " << runtime_1 << " s";

VLOG(1)  << "timestamp 1 end " << std::setprecision(15) << end_1;

        
});

// recycle result vectors _temp_table_epsilon
on_all_cores([=] {
    _temp_table_epsilon.data->clear();
});
        
        auto start_2 = walltime();
VLOG(1)  << "timestamp 2 start " << std::setprecision(15) << start_2;

// GrappaApply(_COLUMN0_=0.001)
MaterializedTupleRef_V3_0 t_001;t_001.f0 = 0.001;
_temp_table_epsilon.data->push_back(t_001);
auto end_2 = walltime();
auto runtime_2 = end_2 - start_2;
VLOG(1)  << "pipeline 2: " << runtime_2 << " s";

VLOG(1)  << "timestamp 2 end " << std::setprecision(15) << end_2;

        
// recycle result vectors _temp_table_prunelimit
on_all_cores([=] {
    _temp_table_prunelimit.data->clear();
});
        
        auto start_3 = walltime();
VLOG(1)  << "timestamp 3 start " << std::setprecision(15) << start_3;

// GrappaApply(_COLUMN0_=1e-05)
MaterializedTupleRef_V5_0 t_003;t_003.f0 = 1e-05;
_temp_table_prunelimit.data->push_back(t_003);
auto end_3 = walltime();
auto runtime_3 = end_3 - start_3;
VLOG(1)  << "pipeline 3: " << runtime_3 << " s";

VLOG(1)  << "timestamp 3 end " << std::setprecision(15) << end_3;

        
// recycle result vectors _temp_table_newchaos
on_all_cores([=] {
    _temp_table_newchaos.data->clear();
});
        
        auto start_4 = walltime();
VLOG(1)  << "timestamp 4 start " << std::setprecision(15) << start_4;

// GrappaApply(_COLUMN0_=1000)
MaterializedTupleRef_V7_0 t_005;t_005.f0 = 1000;
_temp_table_newchaos.data->push_back(t_005);
auto end_4 = walltime();
auto runtime_4 = end_4 - start_4;
VLOG(1)  << "pipeline 4: " << runtime_4 << " s";

VLOG(1)  << "timestamp 4 end " << std::setprecision(15) << end_4;

        
do {

// recycle result vectors _temp_table_oldchaos
on_all_cores([=] {
    _temp_table_oldchaos.data->clear();
});CompletionEvent p_task_5;
spawn(&p_task_5, [=] {

        
        auto start_5 = walltime();
VLOG(1)  << "timestamp 5 start " << std::setprecision(15) << start_5;

forall<&V9>( t_007.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0& t_007) {
_temp_table_oldchaos.data->push_back(t_007);
});
auto end_5 = walltime();
auto runtime_5 = end_5 - start_5;
VLOG(1)  << "pipeline 5: " << runtime_5 << " s";

VLOG(1)  << "timestamp 5 end " << std::setprecision(15) << end_5;

        
});

CompletionEvent p_task_6;
spawn(&p_task_6, [=] {

        
        auto start_6 = walltime();
VLOG(1)  << "timestamp 6 start " << std::setprecision(15) << start_6;

forall<&V11>( t_009.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0& t_009) {
// GrappaBroadcastCrossProduct RIGHT
on_all_cores([=] {
                  t_010 = t_009;
                   });
                   
});
auto end_6 = walltime();
auto runtime_6 = end_6 - start_6;
VLOG(1)  << "pipeline 6: " << runtime_6 << " s";

VLOG(1)  << "timestamp 6 end " << std::setprecision(15) << end_6;

        
});

CompletionEvent p_task_7;
spawn(&p_task_7, [=] {

        
        auto start_7 = walltime();
VLOG(1)  << "timestamp 7 start " << std::setprecision(15) << start_7;

forall<&V22>( t_019.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& t_019) {
// right side of GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]

hash_001.insert_async<&V22>(std::make_tuple(t_019.f0), t_019);
});
auto end_7 = walltime();
auto runtime_7 = end_7 - start_7;
VLOG(1)  << "pipeline 7: " << runtime_7 << " s";

VLOG(1)  << "timestamp 7 end " << std::setprecision(15) << end_7;

        
});

CompletionEvent p_task_8;
spawn(&p_task_8, [=,&p_task_7] {

        p_task_7.wait();
        auto start_8 = walltime();
VLOG(1)  << "timestamp 8 start " << std::setprecision(15) << start_8;

forall<&V23>( t_020.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& t_020) {
// left side of GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]

hash_001.lookup_iter<&V23>( std::make_tuple(t_020.f1), [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& V24) {
  join_coarse_result_count++;
  MaterializedTupleRef_V25_0_1_2_3_4_5 t_021 = create_V26(t_020, V24);
  // GrappaApply(row=$0,value=$2,col1=$4,value1=$5)
MaterializedTupleRef_V20_0_1_2_3 t_018;t_018.f0 = t_021.f0;
t_018.f1 = t_021.f2;
t_018.f2 = t_021.f4;
t_018.f3 = t_021.f5;
// GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))
MaterializedTupleRef_V19_0_1_2 t_017;t_017.f0 = t_018.f0;
t_017.f1 = t_018.f2;
t_017.f2 = ( (t_018.f1) * (t_018.f3) );
// insert of GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]

group_hash_001->update<&V23, MaterializedTupleRef_V19_0_1_2, &__V18_update,&__V18_init>(std::make_tuple(t_017.f0,t_017.f1), t_017);
});
});
auto end_8 = walltime();
auto runtime_8 = end_8 - start_8;
VLOG(1)  << "pipeline 8: " << runtime_8 << " s";

VLOG(1)  << "timestamp 8 end " << std::setprecision(15) << end_8;

        
});

CompletionEvent p_task_9;
spawn(&p_task_9, [=,&p_task_8] {

        p_task_8.wait();
        auto start_9 = walltime();
VLOG(1)  << "timestamp 9 start " << std::setprecision(15) << start_9;

// scan of GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]

group_hash_001->forall_entries<&V28>([=](std::pair<const std::tuple<int64_t,int64_t>,MaterializedTupleRef_V18_0>&V27) {
    MaterializedTupleRef_V29_0_1_2 t_022(std::tuple_cat(V27.first, V27.second.to_tuple()));
    // GrappaApply(col=$1,value=($2 * $2))
MaterializedTupleRef_V17_0_1 t_015;t_015.f0 = t_022.f1;
t_015.f1 = ( (t_022.f2) * (t_022.f2) );
// insert of GrappaGroupBy(col; SUM(value))[GrappaApply(col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]]]

group_hash_000->update<&V28, MaterializedTupleRef_V17_0_1, &__V16_update,&__V16_init>(std::make_tuple(t_015.f0), t_015);
});

auto end_9 = walltime();
auto runtime_9 = end_9 - start_9;
VLOG(1)  << "pipeline 9: " << runtime_9 << " s";

VLOG(1)  << "timestamp 9 end " << std::setprecision(15) << end_9;

        
});

CompletionEvent p_task_10;
spawn(&p_task_10, [=,&p_task_9] {

        p_task_9.wait();
        auto start_10 = walltime();
VLOG(1)  << "timestamp 10 start " << std::setprecision(15) << start_10;

// scan of GrappaGroupBy(col; SUM(value))[GrappaApply(col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]]]

group_hash_000->forall_entries<&V31>([=](std::pair<const std::tuple<int64_t>,MaterializedTupleRef_V16_0>&V30) {
    MaterializedTupleRef_V32_0_1 t_023(std::tuple_cat(V30.first, V30.second.to_tuple()));
    // GrappaApply(col=$0,colsum=$1)
MaterializedTupleRef_V15_0_1 t_013;t_013.f0 = t_023.f0;
t_013.f1 = t_023.f1;
// right side of GrappaHashJoin(($1 = $3))[GrappaApply(row=$0,col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]],GrappaApply(col=$0,colsum=$1)[GrappaGroupBy(col; SUM(value))[GrappaApply(col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]]]]]

hash_000.insert_async<&V31>(std::make_tuple(t_013.f0), t_013);
});

auto end_10 = walltime();
auto runtime_10 = end_10 - start_10;
VLOG(1)  << "pipeline 10: " << runtime_10 << " s";

VLOG(1)  << "timestamp 10 end " << std::setprecision(15) << end_10;

        
});

// recycle result vectors _temp_table_prunedA
on_all_cores([=] {
    _temp_table_prunedA.data->clear();
});CompletionEvent p_task_11;
spawn(&p_task_11, [=,&p_task_8
,&p_task_6
,&p_task_10] {

        p_task_8.wait();
p_task_6.wait();
p_task_10.wait();
        auto start_11 = walltime();
VLOG(1)  << "timestamp 11 start " << std::setprecision(15) << start_11;

// scan of GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]

group_hash_001->forall_entries<&V35>([=](std::pair<const std::tuple<int64_t,int64_t>,MaterializedTupleRef_V18_0>&V34) {
    MaterializedTupleRef_V36_0_1_2 t_025(std::tuple_cat(V34.first, V34.second.to_tuple()));
    // GrappaApply(row=$0,col=$1,value=($2 * $2))
MaterializedTupleRef_V33_0_1_2 t_024;t_024.f0 = t_025.f0;
t_024.f1 = t_025.f1;
t_024.f2 = ( (t_025.f2) * (t_025.f2) );
// left side of GrappaHashJoin(($1 = $3))[GrappaApply(row=$0,col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]],GrappaApply(col=$0,colsum=$1)[GrappaGroupBy(col; SUM(value))[GrappaApply(col=$1,value=($2 * $2))[GrappaGroupBy(row,col; SUM($2))[GrappaApply(row=$0,col1=$2,_COLUMN2_=(value * value))[GrappaApply(row=$0,value=$2,col1=$4,value1=$5)[GrappaHashJoin(($1 = $3))[GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)],GrappaMemoryScan(symmetric_array, matA) [GrappaNullInput(matA)]]]]]]]]]

hash_000.lookup_iter<&V35>( std::make_tuple(t_024.f1), [=](MaterializedTupleRef_V15_0_1& V37) {
  join_coarse_result_count++;
  MaterializedTupleRef_V38_0_1_2_3_4 t_026 = create_V39(t_024, V37);
  // GrappaApply(row=$0,col=$1,value=$2,colsum=$4)
MaterializedTupleRef_V13_0_1_2_3 t_012;t_012.f0 = t_026.f0;
t_012.f1 = t_026.f1;
t_012.f2 = t_026.f2;
t_012.f3 = t_026.f4;
// GrappaApply(row=row,col=col,value=(value / colsum))
MaterializedTupleRef_V12_0_1_2 t_011;t_011.f0 = t_012.f0;
t_011.f1 = t_012.f1;
t_011.f2 = ( (t_012.f2) / (t_012.f3) );
// GrappaBroadcastCrossProduct LEFT

            MaterializedTupleRef_V40_0_1_2_3 t_027 =
              create_V41(t_011, t_010);
              if (( (t_027.f2) > (t_027.f3) )) {
  // GrappaApply(row=row,col=col,value=value)
MaterializedTupleRef_V10_0_1_2 t_008;t_008.f0 = t_027.f0;
t_008.f1 = t_027.f1;
t_008.f2 = t_027.f2;
_temp_table_prunedA.data->push_back(t_008);
}

});
});

auto end_11 = walltime();
auto runtime_11 = end_11 - start_11;
VLOG(1)  << "pipeline 11: " << runtime_11 << " s";

VLOG(1)  << "timestamp 11 end " << std::setprecision(15) << end_11;

        
});

CompletionEvent p_task_12;
spawn(&p_task_12, [=] {

        
        auto start_12 = walltime();
VLOG(1)  << "timestamp 12 start " << std::setprecision(15) << start_12;

forall<&V49>( t_034.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& t_034) {
// GrappaApply(col=$1,_COLUMN1_=(value * value))
MaterializedTupleRef_V48_0_1 t_033;t_033.f0 = t_034.f1;
t_033.f1 = ( (t_034.f2) * (t_034.f2) );
// insert of GrappaGroupBy(col; SUM($1))[GrappaApply(col=$1,_COLUMN1_=(value * value))[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]

group_hash_003->update<&V49, MaterializedTupleRef_V48_0_1, &__V47_update,&__V47_init>(std::make_tuple(t_033.f0), t_033);
});
auto end_12 = walltime();
auto runtime_12 = end_12 - start_12;
VLOG(1)  << "pipeline 12: " << runtime_12 << " s";

VLOG(1)  << "timestamp 12 end " << std::setprecision(15) << end_12;

        
});

CompletionEvent p_task_13;
spawn(&p_task_13, [=,&p_task_12] {

        p_task_12.wait();
        auto start_13 = walltime();
VLOG(1)  << "timestamp 13 start " << std::setprecision(15) << start_13;

// scan of GrappaGroupBy(col; SUM($1))[GrappaApply(col=$1,_COLUMN1_=(value * value))[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]

group_hash_003->forall_entries<&V51>([=](std::pair<const std::tuple<int64_t>,MaterializedTupleRef_V47_0>&V50) {
    MaterializedTupleRef_V52_0_1 t_035(std::tuple_cat(V50.first, V50.second.to_tuple()));
    // GrappaApply(col=$0,sumSquare=$1)
MaterializedTupleRef_V46_0_1 t_031;t_031.f0 = t_035.f0;
t_031.f1 = t_035.f1;
// right side of GrappaHashJoin(($0 = $2))[GrappaApply(col=$0,maxVal=$1)[GrappaGroupBy(col; MAX(value))[GrappaApply(col=$1,value=$2)[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]],GrappaApply(col=$0,sumSquare=$1)[GrappaGroupBy(col; SUM($1))[GrappaApply(col=$1,_COLUMN1_=(value * value))[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]]]

hash_002.insert_async<&V51>(std::make_tuple(t_031.f0), t_031);
});

auto end_13 = walltime();
auto runtime_13 = end_13 - start_13;
VLOG(1)  << "pipeline 13: " << runtime_13 << " s";

VLOG(1)  << "timestamp 13 end " << std::setprecision(15) << end_13;

        
});

CompletionEvent p_task_14;
spawn(&p_task_14, [=] {

        
        auto start_14 = walltime();
VLOG(1)  << "timestamp 14 start " << std::setprecision(15) << start_14;

forall<&V56>( t_039.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& t_039) {
// GrappaApply(col=$1,value=$2)
MaterializedTupleRef_V55_0_1 t_038;t_038.f0 = t_039.f1;
t_038.f1 = t_039.f2;
// insert of GrappaGroupBy(col; MAX(value))[GrappaApply(col=$1,value=$2)[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]

group_hash_004->update<&V56, MaterializedTupleRef_V55_0_1, &__V54_update,&__V54_init>(std::make_tuple(t_038.f0), t_038);
});
auto end_14 = walltime();
auto runtime_14 = end_14 - start_14;
VLOG(1)  << "pipeline 14: " << runtime_14 << " s";

VLOG(1)  << "timestamp 14 end " << std::setprecision(15) << end_14;

        
});

CompletionEvent p_task_15;
spawn(&p_task_15, [=,&p_task_13
,&p_task_14] {

        p_task_13.wait();
p_task_14.wait();
        auto start_15 = walltime();
VLOG(1)  << "timestamp 15 start " << std::setprecision(15) << start_15;

// scan of GrappaGroupBy(col; MAX(value))[GrappaApply(col=$1,value=$2)[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]

group_hash_004->forall_entries<&V58>([=](std::pair<const std::tuple<int64_t>,MaterializedTupleRef_V54_0>&V57) {
    MaterializedTupleRef_V59_0_1 t_040(std::tuple_cat(V57.first, V57.second.to_tuple()));
    // GrappaApply(col=$0,maxVal=$1)
MaterializedTupleRef_V53_0_1 t_036;t_036.f0 = t_040.f0;
t_036.f1 = t_040.f1;
// left side of GrappaHashJoin(($0 = $2))[GrappaApply(col=$0,maxVal=$1)[GrappaGroupBy(col; MAX(value))[GrappaApply(col=$1,value=$2)[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]],GrappaApply(col=$0,sumSquare=$1)[GrappaGroupBy(col; SUM($1))[GrappaApply(col=$1,_COLUMN1_=(value * value))[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]]]

hash_002.lookup_iter<&V58>( std::make_tuple(t_036.f0), [=](MaterializedTupleRef_V46_0_1& V60) {
  join_coarse_result_count++;
  MaterializedTupleRef_V61_0_1_2_3 t_041 = create_V62(t_036, V60);
  // GrappaApply(maxVal=$1,sumSquare=$3)
MaterializedTupleRef_V44_0_1 t_030;t_030.f0 = t_041.f1;
t_030.f1 = t_041.f3;
// GrappaApply(_COLUMN0_=(maxVal - sumSquare))
MaterializedTupleRef_V43_0 t_029;t_029.f0 = ( (t_030.f0) - (t_030.f1) );
auto group_hash_002_local_ptr = group_hash_002.localize();
*group_hash_002_local_ptr = __V42_update(*group_hash_002_local_ptr, t_029);
});
});

auto end_15 = walltime();
auto runtime_15 = end_15 - start_15;
VLOG(1)  << "pipeline 15: " << runtime_15 << " s";

VLOG(1)  << "timestamp 15 end " << std::setprecision(15) << end_15;

        
});

// recycle result vectors _temp_table_newchaos
on_all_cores([=] {
    _temp_table_newchaos.data->clear();
});CompletionEvent p_task_16;
spawn(&p_task_16, [=,&p_task_15] {

        p_task_15.wait();
        auto start_16 = walltime();
VLOG(1)  << "timestamp 16 start " << std::setprecision(15) << start_16;

// scan of GrappaGroupBy(; MAX($0))[GrappaApply(_COLUMN0_=(maxVal - sumSquare))[GrappaApply(maxVal=$1,sumSquare=$3)[GrappaHashJoin(($0 = $2))[GrappaApply(col=$0,maxVal=$1)[GrappaGroupBy(col; MAX(value))[GrappaApply(col=$1,value=$2)[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]],GrappaApply(col=$0,sumSquare=$1)[GrappaGroupBy(col; SUM($1))[GrappaApply(col=$1,_COLUMN1_=(value * value))[GrappaMemoryScan(symmetric_array, prunedA) [GrappaNullInput(prunedA)]]]]]]]]

auto t_042_tmp = reduce<
MaterializedTupleRef_V42_0, &__V42_combine
>(group_hash_002);


MaterializedTupleRef_V64_0 t_042;
t_042.f0 = t_042_tmp.f0;



_temp_table_newchaos.data->push_back(t_042);

// putting a wait here satisfies the invariant that inner code depends
// on global synchronization by the pipeline source
V63.wait();

auto end_16 = walltime();
auto runtime_16 = end_16 - start_16;
VLOG(1)  << "pipeline 16: " << runtime_16 << " s";

VLOG(1)  << "timestamp 16 end " << std::setprecision(15) << end_16;

        
});

// recycle result vectors _temp_table_matA
on_all_cores([=] {
    _temp_table_matA.data->clear();
});CompletionEvent p_task_17;
spawn(&p_task_17, [=] {

        
        auto start_17 = walltime();
VLOG(1)  << "timestamp 17 start " << std::setprecision(15) << start_17;

forall<&V65>( t_043.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0_1_2& t_043) {
_temp_table_matA.data->push_back(t_043);
});
auto end_17 = walltime();
auto runtime_17 = end_17 - start_17;
VLOG(1)  << "pipeline 17: " << runtime_17 << " s";

VLOG(1)  << "timestamp 17 end " << std::setprecision(15) << end_17;

        
});

} while (true);
CompletionEvent p_task_18;
spawn(&p_task_18, [=] {

        
        auto start_18 = walltime();
VLOG(1)  << "timestamp 18 start " << std::setprecision(15) << start_18;

forall<&V66>( t_044.data, [=](MaterializedTupleRef_FAKE_FROM_GRAPPA_NULL_0& t_044) {
result.push_back(t_044);
VLOG(2) << t_044;

});
auto end_18 = walltime();
auto runtime_18 = end_18 - start_18;
VLOG(1)  << "pipeline 18: " << runtime_18 << " s";

VLOG(1)  << "timestamp 18 end " << std::setprecision(15) << end_18;

        
});
p_task_16.wait();
p_task_6.wait();
p_task_9.wait();
p_task_13.wait();
p_task_14.wait();
p_task_11.wait();
p_task_1.wait();
p_task_7.wait();
p_task_8.wait();
p_task_12.wait();
p_task_17.wait();
p_task_18.wait();
p_task_15.wait();
p_task_5.wait();
p_task_10.wait();
auto end_V68 = walltime();
Grappa::Metrics::stop_tracing();
auto runtime_V68 = end_V68 - start_V68;

in_memory_runtime += runtime_V68;
VLOG(1) << "pipeline group V68: " << runtime_V68 << " s";


    // since reset the stats after scan, need to set these again
    scan_runtime = saved_scan_runtime;
    init_runtime = saved_init_runtime;
}


int main(int argc, char** argv) {
    init(&argc, &argv);

    run([] {

    init();
double start = Grappa::walltime();
    	query();
      double end = Grappa::walltime();
      query_runtime = end - start;
      on_all_cores([] { emit_count = result.size(); });
      Metrics::merge_and_print();
    });

    finalize();
    return 0;
}